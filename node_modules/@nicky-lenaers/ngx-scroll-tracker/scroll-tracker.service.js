import { Injectable } from '@angular/core';
import { ReplaySubject } from 'rxjs';
var ScrollTrackerService = (function () {
    function ScrollTrackerService() {
        this._container_manager = new Map();
    }
    /**
     * Register a new Element to be tracked for scrolling.
     *
     * @param element_ref 			The Element Reference
     * @param renderer2 			The Angular RendererV2
     * @returns 					An RxJS Observable
     */
    ScrollTrackerService.prototype.register = function (element_ref, renderer2) {
        var _this = this;
        var container = this._getFirstScrollableParentNode(element_ref.nativeElement);
        if (!this._container_manager.has(container)) {
            this._container_manager.set(container, {
                children: new Map(),
                listener: function (event) { return _this._isElementInContainerView(event, container); }
            });
            var container_listener = this._container_manager.get(container).listener;
            renderer2.listen(this._getListenerTarget(container), 'scroll', container_listener);
            renderer2.listen(this._getListenerTarget(container), 'resize', container_listener);
        }
        // Observable Element Source
        var element_source$ = new ReplaySubject();
        // Push Element to its Container
        this._container_manager
            .get(container)
            .children
            .set(element_ref, element_source$);
        // Initial Test
        this._isElementInContainerView(new Event('ngx-scroll-tracker-initial-event'), container);
        // Return Observable
        return element_source$.asObservable();
    };
    /**
     * Retrieves the Listener target.
     *
     * @param container 				The HTML Container Element
     * @returns 						The Listener Object
     */
    ScrollTrackerService.prototype._getListenerTarget = function (container) {
        return container.tagName === 'BODY' ? window : container;
    };
    /**
     * Evaluate whether the registered Element is in the view or not.
     *
     * @param container 				The Container the Element belongs to
     * @returns void
     */
    ScrollTrackerService.prototype._isElementInContainerView = function (event, container) {
        var _this = this;
        var container_rect = container.getBoundingClientRect();
        this._container_manager.get(container).children.forEach(function (child_value, child_key, map) {
            // Set Element Rectangle
            var element_rect = child_key.nativeElement.getBoundingClientRect();
            var element_height = element_rect.bottom - element_rect.top;
            // Set Container Height and Top
            var container_height = _this._isWindow(_this._getListenerTarget(container)) ? window.innerHeight : (container_rect.bottom - container_rect.top);
            var container_top = _this._isWindow(_this._getListenerTarget(container)) ? 0 : container_rect.top;
            // Set Event Data
            var event_data = {
                $event: event,
                elementRef: child_key,
                data: {
                    elementTop: {
                        fromContainerTop: {
                            pixels: element_rect.top - container_top,
                            ratio: (element_rect.top - container_top) / container_height
                        },
                        fromContainerBottom: {
                            pixels: element_rect.top - (container_height + container_top),
                            ratio: (element_rect.top - (container_height + container_top)) / container_height
                        }
                    },
                    elementBottom: {
                        fromContainerTop: {
                            pixels: (element_rect.top + element_height) - container_top,
                            ratio: ((element_rect.top + element_height) - container_top) / container_height
                        },
                        fromContainerBottom: {
                            pixels: (element_rect.top + element_height) - (container_height + container_top),
                            ratio: ((element_rect.top + element_height) - (container_height + container_top)) / container_height
                        }
                    }
                }
            };
            // Emit Value
            _this._container_manager
                .get(container)
                .children
                .get(child_key)
                .next(event_data);
        });
    };
    /**
     * Test if a given Element is the Window.
     *
     * @param container 				The given Element
     * @returns 						Boolean if given Element is Window
     */
    ScrollTrackerService.prototype._isWindow = function (container) {
        return container === window;
    };
    /**
     * Find the first scrollable parent node of an element.
     *
     * @param nativeElement 			The element to search from
     * @param includeHidden 			Whether to include hidden elements or not
     * @returns 						The first scrollable parent node
     */
    ScrollTrackerService.prototype._getFirstScrollableParentNode = function (nativeElement, includeHidden) {
        if (includeHidden === void 0) { includeHidden = true; }
        var style = window.getComputedStyle(nativeElement);
        var overflow_regex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/;
        if (style.position === 'fixed')
            throw new Error("Scroll item cannot be positioned 'fixed'");
        // Recursive Loop Parents
        for (var parent_1 = nativeElement; parent_1 = parent_1.parentElement;) {
            // Recalculate Style
            style = window.getComputedStyle(parent_1);
            // Skip Absolute Positioning
            if (style.position === 'absolute')
                continue;
            // Return Body
            if (parent_1.tagName === 'BODY')
                return parent_1;
            // Test Overflow
            if (overflow_regex.test(style.overflow + style.overflowY + style.overflowX))
                return parent_1;
        }
        throw new Error("No scrollable parent found for element " + nativeElement);
    };
    /**
     * Unregisters an Element from being tracked for scrolling.
     *
     * @param element  			The Element to unregister
     * @returns void
     */
    ScrollTrackerService.prototype._unregister = function (element) {
        var _this = this;
        this._container_manager.forEach(function (container_value, container_key, container_map) {
            container_value.children.forEach(function (child_value, child_key, element_map) {
                if (child_key.nativeElement === element.nativeElement) {
                    // Remove Element from Container
                    _this._container_manager.get(container_key).children.delete(child_key);
                    // No more Element to be tracked
                    if (_this._container_manager.get(container_key).children.size === 0) {
                        // Cleanup
                        _this._container_manager.delete(container_key);
                    }
                }
            });
        });
    };
    return ScrollTrackerService;
}());
export { ScrollTrackerService };
ScrollTrackerService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ScrollTrackerService.ctorParameters = function () { return []; };
//# sourceMappingURL=scroll-tracker.service.js.map