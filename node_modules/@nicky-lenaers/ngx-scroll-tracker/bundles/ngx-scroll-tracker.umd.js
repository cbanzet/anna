(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/platform-browser'), require('rxjs')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/common', '@angular/platform-browser', 'rxjs'], factory) :
	(factory((global.ng = global.ng || {}, global.ng['ngx-scroll-tracker'] = global.ng['ngx-scroll-tracker'] || {}),global.ng.core,global.ng.common,global.ng.platformBrowser,global.rxjs));
}(this, (function (exports,_angular_core,_angular_common,_angular_platformBrowser,rxjs) { 'use strict';

var ScrollTrackerService = (function () {
    function ScrollTrackerService() {
        this._container_manager = new Map();
    }
    /**
     * Register a new Element to be tracked for scrolling.
     *
     * @param element_ref 			The Element Reference
     * @param renderer2 			The Angular RendererV2
     * @returns 					An RxJS Observable
     */
    ScrollTrackerService.prototype.register = function (element_ref, renderer2) {
        var _this = this;
        var container = this._getFirstScrollableParentNode(element_ref.nativeElement);
        if (!this._container_manager.has(container)) {
            this._container_manager.set(container, {
                children: new Map(),
                listener: function (event) { return _this._isElementInContainerView(event, container); }
            });
            var container_listener = this._container_manager.get(container).listener;
            renderer2.listen(this._getListenerTarget(container), 'scroll', container_listener);
            renderer2.listen(this._getListenerTarget(container), 'resize', container_listener);
        }
        // Observable Element Source
        var element_source$ = new rxjs.ReplaySubject();
        // Push Element to its Container
        this._container_manager
            .get(container)
            .children
            .set(element_ref, element_source$);
        // Initial Test
        this._isElementInContainerView(new Event('ngx-scroll-tracker-initial-event'), container);
        // Return Observable
        return element_source$.asObservable();
    };
    /**
     * Retrieves the Listener target.
     *
     * @param container 				The HTML Container Element
     * @returns 						The Listener Object
     */
    ScrollTrackerService.prototype._getListenerTarget = function (container) {
        return container.tagName === 'BODY' ? window : container;
    };
    /**
     * Evaluate whether the registered Element is in the view or not.
     *
     * @param container 				The Container the Element belongs to
     * @returns void
     */
    ScrollTrackerService.prototype._isElementInContainerView = function (event, container) {
        var _this = this;
        var container_rect = container.getBoundingClientRect();
        this._container_manager.get(container).children.forEach(function (child_value, child_key, map) {
            // Set Element Rectangle
            var element_rect = child_key.nativeElement.getBoundingClientRect();
            var element_height = element_rect.bottom - element_rect.top;
            // Set Container Height and Top
            var container_height = _this._isWindow(_this._getListenerTarget(container)) ? window.innerHeight : (container_rect.bottom - container_rect.top);
            var container_top = _this._isWindow(_this._getListenerTarget(container)) ? 0 : container_rect.top;
            // Set Event Data
            var event_data = {
                $event: event,
                elementRef: child_key,
                data: {
                    elementTop: {
                        fromContainerTop: {
                            pixels: element_rect.top - container_top,
                            ratio: (element_rect.top - container_top) / container_height
                        },
                        fromContainerBottom: {
                            pixels: element_rect.top - (container_height + container_top),
                            ratio: (element_rect.top - (container_height + container_top)) / container_height
                        }
                    },
                    elementBottom: {
                        fromContainerTop: {
                            pixels: (element_rect.top + element_height) - container_top,
                            ratio: ((element_rect.top + element_height) - container_top) / container_height
                        },
                        fromContainerBottom: {
                            pixels: (element_rect.top + element_height) - (container_height + container_top),
                            ratio: ((element_rect.top + element_height) - (container_height + container_top)) / container_height
                        }
                    }
                }
            };
            // Emit Value
            _this._container_manager
                .get(container)
                .children
                .get(child_key)
                .next(event_data);
        });
    };
    /**
     * Test if a given Element is the Window.
     *
     * @param container 				The given Element
     * @returns 						Boolean if given Element is Window
     */
    ScrollTrackerService.prototype._isWindow = function (container) {
        return container === window;
    };
    /**
     * Find the first scrollable parent node of an element.
     *
     * @param nativeElement 			The element to search from
     * @param includeHidden 			Whether to include hidden elements or not
     * @returns 						The first scrollable parent node
     */
    ScrollTrackerService.prototype._getFirstScrollableParentNode = function (nativeElement, includeHidden) {
        if (includeHidden === void 0) { includeHidden = true; }
        var style = window.getComputedStyle(nativeElement);
        var overflow_regex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/;
        if (style.position === 'fixed')
            throw new Error("Scroll item cannot be positioned 'fixed'");
        // Recursive Loop Parents
        for (var parent_1 = nativeElement; parent_1 = parent_1.parentElement;) {
            // Recalculate Style
            style = window.getComputedStyle(parent_1);
            // Skip Absolute Positioning
            if (style.position === 'absolute')
                continue;
            // Return Body
            if (parent_1.tagName === 'BODY')
                return parent_1;
            // Test Overflow
            if (overflow_regex.test(style.overflow + style.overflowY + style.overflowX))
                return parent_1;
        }
        throw new Error("No scrollable parent found for element " + nativeElement);
    };
    /**
     * Unregisters an Element from being tracked for scrolling.
     *
     * @param element  			The Element to unregister
     * @returns void
     */
    ScrollTrackerService.prototype._unregister = function (element) {
        var _this = this;
        this._container_manager.forEach(function (container_value, container_key, container_map) {
            container_value.children.forEach(function (child_value, child_key, element_map) {
                if (child_key.nativeElement === element.nativeElement) {
                    // Remove Element from Container
                    _this._container_manager.get(container_key).children.delete(child_key);
                    // No more Element to be tracked
                    if (_this._container_manager.get(container_key).children.size === 0) {
                        // Cleanup
                        _this._container_manager.delete(container_key);
                    }
                }
            });
        });
    };
    return ScrollTrackerService;
}());
ScrollTrackerService.decorators = [
    { type: _angular_core.Injectable },
];
/** @nocollapse */
ScrollTrackerService.ctorParameters = function () { return []; };

var ScrollTrackerDirective = (function () {
    function ScrollTrackerDirective(_element_ref, _scrollTrackerService, _renderer2, _document, _platform_id) {
        this._element_ref = _element_ref;
        this._scrollTrackerService = _scrollTrackerService;
        this._renderer2 = _renderer2;
        this._document = _document;
        this._platform_id = _platform_id;
        this.ngxScrollTrackerHandler = new _angular_core.EventEmitter();
    }
    /**
     * Angular Lifecycle Hook - After Content Init
     * @source https://angular.io/api/core/AfterContentInit
     *
     * @returns void
     */
    ScrollTrackerDirective.prototype.ngAfterContentInit = function () {
        var _this = this;
        if (_angular_common.isPlatformServer(this._platform_id))
            return;
        // Kicks off the next Angular Lifecycle
        setTimeout(function (__HACK__) {
            // Subscribe to Scroll Events...
            _this._subscription = _this._scrollTrackerService
                .register(_this._element_ref, _this._renderer2)
                .finally(function () { return _this._cleanup(); })
                .subscribe(function (value) { return _this.ngxScrollTrackerHandler.emit(value); }, function (error) { return console.error(error); });
        });
    };
    /**
     * Angular Lifecycle Hook - On Destroy
     * @source https://angular.io/api/core/OnDestroy
     *
     * @returns void
     */
    ScrollTrackerDirective.prototype.ngOnDestroy = function () {
        if (_angular_common.isPlatformServer(this._platform_id))
            return;
        this._cleanup();
    };
    /**
     * Clean up subscription.
     *
     * @return void
     */
    ScrollTrackerDirective.prototype._cleanup = function () {
        this._subscription.unsubscribe();
    };
    return ScrollTrackerDirective;
}());
ScrollTrackerDirective.decorators = [
    { type: _angular_core.Directive, args: [{
                selector: '[ngx-scroll-tracker]'
            },] },
];
/** @nocollapse */
ScrollTrackerDirective.ctorParameters = function () { return [
    { type: _angular_core.ElementRef, },
    { type: ScrollTrackerService, },
    { type: _angular_core.Renderer2, },
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.PLATFORM_ID,] },] },
]; };
ScrollTrackerDirective.propDecorators = {
    'ngxScrollTrackerHandler': [{ type: _angular_core.Output, args: ['ngx-scroll-tracker',] },],
};

var ScrollTrackerModule = (function () {
    function ScrollTrackerModule() {
    }
    /**
     * Guaranteed singletons for provided Services across App.
     *
     * @return 				An Angular Module with Providers
     */
    ScrollTrackerModule.forRoot = function () {
        return {
            ngModule: ScrollTrackerModule,
            providers: [
                ScrollTrackerService
            ]
        };
    };
    return ScrollTrackerModule;
}());
ScrollTrackerModule.decorators = [
    { type: _angular_core.NgModule, args: [{
                imports: [
                    _angular_common.CommonModule
                ],
                declarations: [
                    ScrollTrackerDirective
                ],
                exports: [
                    ScrollTrackerDirective
                ]
            },] },
];
/** @nocollapse */
ScrollTrackerModule.ctorParameters = function () { return []; };

exports.ScrollTrackerModule = ScrollTrackerModule;

Object.defineProperty(exports, '__esModule', { value: true });

})));
